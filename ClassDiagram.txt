@startuml
interface "Runnable" as Runnable
interface "List" as List

interface Runnable {
	+run() : void
}
class Number
class Queue {
	- {static} final long serialVersionUID = 1L
	+ {static} int WAIT_TIME = 1000
	- {static} int SIZE = 10000
	- int readCursor
	- int writeCursor
	- Object queueLock
	- int numberOfPrimeNumbersWanted
	- int primeNumbersFound = 0
	+ Queue(int) : Queue
	- synchronized getReadCursor() : int
	- setReadCursor(int) : void
	- incrementReadCursor() : void
	# synchronized getWriteCursor() : int
	- setWriteCursor(int) : void
	- incrementWriteCursor() : void
	- getNumberOfPrimeNumbersWanted() : int
	- setNumberOfPrimeNumbersWanted(int) : void
	- getPrimeNumbersFound() : int
	- setPrimeNumbersFound(int) : void
	# synchronized incrementPrimeNumbersFound() : void
	- isValidNumberOfPrimeNumbers(int) : boolean
	# synchronized isReadable() : boolean
	# synchronized isWritable() : boolean
	# synchronized primeNumbersComputeComplete() : boolean
	- read(int) : Number
	# synchronized read() : Number
	# synchronized write(Number) : void 
}

abstract class Worker {
	# Queue queue
	+getQueue() : Queue
	+setQueue(Queue) : void
	+ {static} isPrime(int) : boolean
}

class Consumer {
	-String resultFileName
	-Object fileLock
	+consume() : void
	+run() : void
	+canConsume() : boolean
	+finished() : boolean
	+writeToFile(Integer) : boolean
}

class Producer {
	-boolean finishedWork
	-Integer maxRange
	-Integer currentIndex
	+produce() : void
	+run() : void()
	+canProduce() : boolean
}

List <|.. ArrayList
ArrayList <|-- Queue
Number *-- Queue : uses
Queue *-- Worker
Runnable <|.. Consumer
Runnable <|.. Producer
Worker <|-- Consumer
Worker <|-- Producer


@enduml
